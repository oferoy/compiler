/***************************/
/* FILE NAME: CUP_FILE.cup */
/***************************/

import java_cup.runtime.*;
import ast.*;

/**********************/
/* PARSER DECLARATION */
/**********************/
parser code {:
    public Lexer lexer;

    public Parser(Lexer lexer)
    {
        super(lexer);
        this.lexer = lexer;
    }

    @Override
    public void report_error(String message, Object info)
    {
        // Required format: ERROR(<line>)
        int line = lexer.getLine();
        if (line <= 0) line = 1;
        throw new RuntimeException("ERROR(" + line + ")");
    }

    @Override
    public void report_fatal_error(String msg, Object info)
    {
        int line = lexer.getLine();
        if (line <= 0) line = 1;
        throw new RuntimeException("ERROR(" + line + ")");
    }
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
    return lexer.next_token();
:};

/*************/
/* TERMINALS */
/*************/
terminal CLASS, ARRAY, WHILE, EXTENDS, RETURN, NEW, IF, ELSE;

terminal TYPE_INT, TYPE_VOID, TYPE_STRING, NIL;

terminal EQ, LT, GT;
terminal PLUS, MINUS, TIMES, DIVIDE;

terminal DOT, ASSIGN, SEMICOLON, COMMA;

terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;

/* LITERALS */
terminal Integer INT;
terminal String  STRING;
terminal String  ID;

/*****************/
/* NON TERMINALS */
/*****************/

/* Program + declarations */
non terminal AstProgram  program;
non terminal AstDecList  decList;
non terminal AstDec      dec;
non terminal AstDecVar   varDec;
non terminal AstDecFunc  funcDec;
non terminal AstDec      classDec;
non terminal AstDec      arrayTypedef;

/* Types and parameter lists */
non terminal String          typeName;       // "int", "string", "void", or class name
non terminal AstTypeNameList funcArgs;
non terminal AstClassBody    classMembers;

/* Statements */
non terminal AstStmt     stmt;
non terminal AstStmtList stmtList;

/* Expressions / variables / calls */
non terminal AstExpVar   var;
non terminal AstExp      exp;
non terminal AstExpCall  callExp;
non terminal AstExp      newExp;
non terminal AstExpList  expList;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/

/* Lowest precedence */
precedence right ASSIGN;           // :=

precedence left EQ;                // =
precedence left LT, GT;            // < >

precedence left PLUS, MINUS;       // + -

precedence left TIMES, DIVIDE;     // * /

// Highest precedence
precedence left LBRACK;            // [...]
precedence left LPAREN;            // function call ( )
precedence left DOT;               // field access .

/************************/
/* START WITH: program  */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/

/* program ::= decList */
program ::=
      decList:dl
        {:
            AstProgram p = new AstProgram(dl, null);
            // program-level line rarely used; take from first decl if exists
            if (dl != null) p.lineNumber = dl.lineNumber;
            RESULT = p;
        :}
    ;

/* ----------------- */
/*  Types as strings */
/* ----------------- */

typeName ::=
      TYPE_INT
        {: RESULT = "int"; :}
    | TYPE_STRING
        {: RESULT = "string"; :}
    | TYPE_VOID
        {: RESULT = "void"; :}
    | ID:id
        {: RESULT = id; :}
    ;

/* ------------------------ */
/*  Declaration list, dec   */
/* ------------------------ */

decList ::=
      dec:d
        {:
            AstDecList l = new AstDecList(d, null);
            l.lineNumber = d.lineNumber;
            RESULT = l;
        :}
    | dec:d decList:dl
        {:
            AstDecList l = new AstDecList(d, dl);
            l.lineNumber = d.lineNumber;
            RESULT = l;
        :}
    ;

dec ::=
      varDec:vd
        {: RESULT = vd; :}
    | funcDec:fd
        {: RESULT = fd; :}
    | classDec:cd
        {: RESULT = cd; :}
    | arrayTypedef:ad
        {: RESULT = ad; :}
    ;

/* ----------------- */
/*  Variable decl    */
/* ----------------- */
/* varDec ::=
 *     typeName ID [ ASSIGN exp ] SEMICOLON
 *   | typeName ID ASSIGN newExp SEMICOLON
 */
varDec ::=
      typeName:tn ID:id SEMICOLON
        {:
            AstDecVar v = new AstDecVar(tn, id, null);
            v.lineNumber = idleft + 1;
            RESULT = v;
        :}
    | typeName:tn ID:id ASSIGN exp:e SEMICOLON
        {:
            AstDecVar v = new AstDecVar(tn, id, e);
            v.lineNumber = idleft + 1;
            RESULT = v;
        :}
    | typeName:tn ID:id ASSIGN newExp:n SEMICOLON
        {:
            AstDecVar v = new AstDecVar(tn, id, n);
            v.lineNumber = idleft + 1;
            RESULT = v;
        :}
    ;

/* ----------------- */
/*  Function decl    */
/* ----------------- */
/* funcDec ::= typeName ID LPAREN [ typeName ID { , typeName ID } ] RPAREN LBRACE stmtList RBRACE */

funcDec ::=
      typeName:tn ID:id LPAREN RPAREN LBRACE stmtList:body RBRACE
        {:
            AstDecFunc f = new AstDecFunc(tn, id, null, body);
            f.lineNumber = idleft + 1;   // function name line
            RESULT = f;
        :}
    | typeName:tn ID:id LPAREN funcArgs:params RPAREN LBRACE stmtList:body RBRACE
        {:
            AstDecFunc f = new AstDecFunc(tn, id, params, body);
            f.lineNumber = idleft + 1;
            RESULT = f;
        :}
    ;


/* funcArgs ::= typeName ID { , typeName ID } 
 * represented as AstTypeNameList(AstTypeName(type,name), tail)
 */
funcArgs ::=
      typeName:tn ID:id
        {:
            AstTypeNameList l =
                new AstTypeNameList(new AstTypeName(tn, id), null);
            l.lineNumber = idleft + 1;
            RESULT = l;
        :}
    | funcArgs:pl COMMA typeName:tn ID:id
        {:
            AstTypeNameList l =
                new AstTypeNameList(new AstTypeName(tn, id), pl);
            l.lineNumber = idleft + 1;
            RESULT = l;
        :}
    ;

/* ------------- */
/*  Class decl   */
/* ------------- */
/* classDec ::= CLASS ID [ EXTENDS ID ] LBRACE classMembers RBRACE
 * classMembers builds both a field list and a method list.
 */

classDec ::= 
      CLASS:c ID:id LBRACE classMembers:cm RBRACE
        {:
            AstDecClass cls = new AstDecClass(id, cm.fields, cm.methods);
            cls.lineNumber = idleft + 1;   // class name line
            RESULT = cls;
        :}
    | CLASS:c ID:id EXTENDS ID:base LBRACE classMembers:cm RBRACE
        {:
            AstDecClass cls = new AstDecClass(id, base, cm.fields, cm.methods);
            cls.lineNumber = idleft + 1;
            RESULT = cls;
        :}
    ;


/* ---------------- */
/*  Class members   */
/* ---------------- */
/* classMembers ::= zero or more fields and methods, in any order.
 * We accumulate:
 *   - fields into an AstTypeNameList
 *   - methods into an AstDecList
 */

classMembers ::=
      /* empty */
        {:
            AstClassBody cm = new AstClassBody(null, null);
            RESULT = cm;
        :}
    /* add a plain field: typeName ID ; */
    | classMembers:cm typeName:tn ID:fid SEMICOLON
        {:
            AstTypeName field = new AstTypeName(tn, fid);
            field.lineNumber = fidleft + 1;

            cm.fields = new AstTypeNameList(field, cm.fields);
            RESULT = cm;
        :}
    /* add an initialized field: typeName ID := exp ; */
    | classMembers:cm typeName:tn ID:fid ASSIGN exp:e SEMICOLON
        {:
            AstTypeName field = new AstTypeName(tn, fid);
            field.lineNumber = fidleft + 1;
            field.initValue = e;

            cm.fields = new AstTypeNameList(field, cm.fields);
            RESULT = cm;
        :}
    /* add a method: funcDec */
    | classMembers:cm funcDec:fd
        {:
            cm.methods = new AstDecList(fd, cm.methods);
            RESULT = cm;
        :}
    ;



/* ---------------- */
/*  Array typedef   */
/* ---------------- */
/* arrayTypedef ::= ARRAY ID EQ typeName LBRACK RBRACK SEMICOLON */

arrayTypedef ::=
      ARRAY ID:id EQ typeName:tn LBRACK RBRACK SEMICOLON
        {:
            AstDecArray arr = new AstDecArray(id, new AstTypeName(tn, null));
            arr.lineNumber = idleft + 1;   // line of the typedef name
            RESULT = arr;
        :}
    ;


/* ---------------- */
/*  stmtList        */
/* ---------------- */
/* stmtList ::= stmt { stmt } */

stmtList ::=
      stmt:s
        {:
            AstStmtList l = new AstStmtList(s, null);
            l.lineNumber = s.lineNumber;
            RESULT = l;
        :}
    | stmt:s stmtList:sl
        {:
            AstStmtList l = new AstStmtList(s, sl);
            l.lineNumber = s.lineNumber;
            RESULT = l;
        :}
    ;

/* ------------- */
/*  Statements   */
/* ------------- */

stmt ::=
      /* varDec as a statement */
      varDec:vd
        {:
            AstStmtDecVar s = new AstStmtDecVar(vd);
            s.lineNumber = vd.lineNumber;
            RESULT = s;
        :}

    /* var ASSIGN exp SEMICOLON */
    | var:v ASSIGN exp:e SEMICOLON
        {:
            AstStmtAssign s = new AstStmtAssign(v, e);
            s.lineNumber = vleft + 1;   // location of the LHS variable
            RESULT = s;
        :}

    /* var ASSIGN newExp SEMICOLON */
    | var:v ASSIGN newExp:n SEMICOLON
        {:
            AstStmtAssign s = new AstStmtAssign(v, n);
            s.lineNumber = vleft + 1;
            RESULT = s;
        :}

    /* RETURN [ exp ] SEMICOLON */
    | RETURN:ret exp:e SEMICOLON
        {:
            AstStmtReturn s = new AstStmtReturn(e);
            s.lineNumber = retleft + 1;
            RESULT = s;
        :}
    | RETURN:ret SEMICOLON
        {:
            AstStmtReturn s = new AstStmtReturn(null);
            s.lineNumber = retleft + 1;
            RESULT = s;
        :}

        /* IF (...) { stmtList } */
    | IF:iff LPAREN exp:c RPAREN LBRACE stmtList:th RBRACE
        {:
            AstStmtIf s = new AstStmtIf(c, th, null);
            s.lineNumber = iffleft + 1;    // line of 'if'
            RESULT = s;
        :}

    /* IF (...) { stmtList } ELSE { stmtList } */
    | IF:iff LPAREN exp:c RPAREN LBRACE stmtList:th RBRACE
      ELSE LBRACE stmtList:el RBRACE
        {:
            AstStmtIf s = new AstStmtIf(c, th, el);
            s.lineNumber = iffleft + 1;    // line of 'if'
            RESULT = s;
        :}

    /* WHILE (...) { stmtList } */
    | WHILE:wh LPAREN exp:c RPAREN LBRACE stmtList:body RBRACE
        {:
            AstStmtWhile s = new AstStmtWhile(c, body);
            s.lineNumber = whleft + 1;     // line of 'while'
            RESULT = s;
        :}

    /* callExp SEMICOLON */
    | callExp:c SEMICOLON
        {:
            AstStmtCall s = new AstStmtCall(c);
            s.lineNumber = c.lineNumber;
            RESULT = s;
        :}
    ;

/* ------------- */
/*  Variables    */
/* ------------- */
/* var ::= ID | var DOT ID | var LBRACK exp RBRACK */

var ::=
      ID:id
        {:
            AstExpVarSimple v = new AstExpVarSimple(id);
            v.lineNumber = idleft + 1;      // line of the identifier
            RESULT = v;
        :}
    | var:v DOT ID:id
        {:
            AstExpVarField f = new AstExpVarField(v, id);
            f.lineNumber = vleft + 1;       // base var line
            RESULT = f;
        :}
    | var:v LBRACK exp:e RBRACK
        {:
            AstExpVarSubscript s = new AstExpVarSubscript(v, e);
            s.lineNumber = vleft + 1;       // base var line
            RESULT = s;
        :}
    ;

/* ------------- */
/*  Expressions  */
/* ------------- */
/* exp ::= var
 *       | ( exp )
 *       | exp (PLUS | MINUS | TIMES | DIVIDE | LT | GT | EQ) exp
 *       | callExp
 *       | [ MINUS ] INT | NIL | STRING
 */

exp ::=
      var:v
        {:
            // var already has lineNumber
            RESULT = v;
        :}
    | LPAREN exp:e RPAREN
        {:
            RESULT = e;
        :}
    | exp:l PLUS exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.PLUS);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l MINUS exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.MINUS);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l TIMES exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.TIMES);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l DIVIDE exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.DIVIDE);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l LT exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.LT);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l GT exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.GT);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | exp:l EQ exp:r
        {:
            AstExpBinop b = new AstExpBinop(l, r, AstExpBinop.EQ);
            b.lineNumber = l.lineNumber;
            RESULT = b;
        :}
    | callExp:c
        {:
            RESULT = c;      // callExp will carry its lineNumber
        :}
    | INT:i
        {:
            AstExpInt e = new AstExpInt(i);
            e.lineNumber = ileft + 1;
            RESULT = e;
        :}
    | MINUS INT:i
        {:
            AstExpInt e = new AstExpInt(-i);
            e.lineNumber = ileft + 1;
            RESULT = e;
        :}
    | NIL:n
        {:
            AstExpNil e = new AstExpNil();
            e.lineNumber = nleft + 1;
            RESULT = e;
        :}
    | STRING:s
        {:
            AstExpString e = new AstExpString(s);
            e.lineNumber = sleft + 1;
            RESULT = e;
        :}
    ;

/* ---------------- */
/*  newExp          */
/* ---------------- */
/* newExp ::= NEW typeName | NEW typeName LBRACK exp RBRACK */

newExp ::=
      NEW:n typeName:tn
        {:
            AstExpNewClass e = new AstExpNewClass(tn);
            e.lineNumber = nleft + 1;
            RESULT = e;
        :}
    | NEW:n typeName:tn LBRACK exp:e RBRACK
        {:
            AstExpNewArray a = new AstExpNewArray(new AstTypeName(tn, null), e);
            a.lineNumber = nleft + 1;
            RESULT = a;
        :}
    ;

/* ---------------- */
/*  Function calls  */
/* ---------------- */
/* callExp ::= [ var DOT ] ID LPAREN [ exp { COMMA exp } ] RPAREN */
/* Encode obj.m(a,b) as m(obj,a,b) in AstExpCall */

callExp ::=
      /* plain global call: f() */
      ID:id LPAREN RPAREN
        {:
            AstExpCall c = new AstExpCall(id, null);
            c.lineNumber = idleft + 1;
            RESULT = c;
        :}

    /* plain global call: f(e1, e2, ...) */
    | ID:id LPAREN expList:el RPAREN
        {:
            AstExpCall c = new AstExpCall(id, el);
            c.lineNumber = idleft + 1;
            RESULT = c;
        :}

    /* method-style call with no extra args: obj.m() -> m(obj) */
    | var:v DOT ID:id LPAREN RPAREN
        {:
            AstExpCall c = new AstExpCall(id, new AstExpList(v, null));
            c.lineNumber = v.lineNumber;    // base object line
            RESULT = c;
        :}

    /* method-style call with args: obj.m(e1, e2, ...) -> m(obj, e1, e2, ...) */
    | var:v DOT ID:id LPAREN expList:el RPAREN
        {:
            AstExpCall c = new AstExpCall(id, new AstExpList(v, el));
            c.lineNumber = v.lineNumber;
            RESULT = c;
        :}
    ;


/* ---------------- */
/*  expList         */
/* ---------------- */
/* expList ::= exp { COMMA exp } */

expList ::=
      exp:e
        {:
            AstExpList l = new AstExpList(e, null);
            l.lineNumber = e.lineNumber;
            RESULT = l;
        :}
    | expList:el COMMA exp:e
        {:
            AstExpList l = new AstExpList(e, el);
            l.lineNumber = e.lineNumber;
            RESULT = l;
        :}
    ;
